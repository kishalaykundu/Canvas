/**
 * @file main.cpp
 * @author Kishalay Kundu <kishalay.kundu@gmail.com>
 * @section LICENSE
 * See LICENSE.txt included in this package
 *
 * @section DESCRIPTION
 * The main source file for the automatic enumerated type generator
 * for the Canvas system. This program reads an XML-style config file
 * and automatically generates various enum types to be used by the
 * main canvas simulation system. The XML-style input config file
 * contains the location where the "Types.h" file is to be written to.
 */

#include <cstdio>
#include <cstdlib>
#include <string>

#include "tinyxml2.h"
#include "Log.h"
#include "ConfigParser.h"

using std::string;
using tinyxml2::XMLElement;
using tinyxml2::XMLError;
using tinyxml2::XML_SUCCESS;

int main (int argc, const char** argv)
{
	// sanity check
	if (argc == 2) {
		if (!strcmp (argv [1], "-h") || !strcmp (argv [1], "--help")){
			LOG ("Usage: ./Bin/simulate <config file> (default: Assets/Config/AppConfig.xml)");
			exit (EXIT_SUCCESS);
		}
	}

	// get the input configuration file (default:Assets/Config/EnumTypes.xml)
	const char* input = nullptr;
	if (argc < 2){
		input = "Assets/Config/EnumTypes.xml";
		LOG ("No input file specified, default " << input << " being used");
	} else {
		input = argv [1];
	}

	// open input configuration file
	Sim::ConfigParser cp;
	if (!cp.Initialize (input, "EnumTypes")){
		LOG_ERROR ("Could not initialize parser for " << input << "...Aborting");
		exit (EXIT_FAILURE);
	}

	// get the location of output file
	XMLElement* element = cp.GetElement ("Output");
	if (element == nullptr){
		LOG_ERROR ("No output folder specified by " << input << "...Aborting");
		exit (EXIT_FAILURE);
	}
	const char* location = element->Attribute ("Location");
	if (location == nullptr){
		LOG_ERROR ("No Location specified in \'Ouput\' element in " << input << "...Aborting");
		exit (EXIT_FAILURE);
	}

	element = cp.GetElement ("EnumType");
	if (element == nullptr){
		LOG_ERROR ("No enum types are specified in " << input << "...Aborting");
		exit (EXIT_FAILURE);
	}

	// generate file-name with location
	string file (location);
	if (file [file.length () - 1] != '/'){
		file += "/";
	}
	file += "Types.h";

	FILE* fp = fopen (file.c_str (), "w");

	// generate the comment header
	fprintf (fp, "/**\n");
	fprintf (fp, " * @file Types.h\n");
	fprintf (fp, " * @author Kishalay Kundu <kishalay.kundu@gmail.com>\n");
	fprintf (fp, " * @section LICENSE\n");
	fprintf (fp, " * See LICENSE.txt included in this package\n");
	fprintf (fp, " *\n");
	fprintf (fp, " * @section DESCRIPTION\n");
	fprintf (fp, " * Enum classes used by the Canvas simulate system. Types.h is\n");
	fprintf (fp, " * automatically generated by the generateEnums program based on\n");
	fprintf (fp, " * input in %s.\n", input);
	fprintf (fp, " */\n\n\n");

	fprintf (fp, "namespace Sim {\n\n");

	// all customized enums written here
	while (element != nullptr){

		const char* name = element->Attribute ("Name");
		if (name == nullptr){
			LOG_WARNING ("No name specified for \'EnumType\' element in " << input <<
					". No enum class generated. Proceeding with next element.");
		}
		else {

			fprintf (fp, "\t enum class %s {\n", name);

			XMLElement* type = element->FirstChildElement ("Type");
			while (type != nullptr){
				if (type->NextSiblingElement ("Type") != nullptr){
					fprintf (fp, "\t\t%s,\n", type->GetText ());
				}
				else { // get rid of trailing comma for last element
					fprintf (fp, "\t\t%s\n", type->GetText ());
				}
				type = type->NextSiblingElement ("Type");
			}

			fprintf (fp, "\t };\n\n");
		}

		element = element->NextSiblingElement ("EnumType");
	}

	fprintf (fp, "}\n");

	// close file
	fclose (fp);

	exit (EXIT_SUCCESS);
}
