/**
 * @file main.cpp
 * @author Kishalay Kundu <kishalay.kundu@gmail.com>
 * @section LICENSE
 * See LICENSE.txt included in this package
 *
 * @section DESCRIPTION
 * The main source file for the automatic enumerated type generator
 * for the Canvas system. This program reads an XML-style config file
 * and automatically generates various enum types to be used by the
 * main canvas simulation system. The XML-style input config file
 * contains the location where the "Types.h" file is to be written to.
 */

#include <cstdlib>
#include <iostream>
#include <fstream>
#include <string>

#include "tinyxml2.h"
#include "Log.h"
#include "ConfigParser.h"

using std::ios;
using std::ofstream;
using std::endl;
using std::string;
using tinyxml2::XMLElement;
using tinyxml2::XMLError;
using tinyxml2::XML_SUCCESS;

int main (int argc, const char** argv)
{
	// sanity check
	if (argc == 2) {
		if (!strcmp (argv [1], "-h") || !strcmp (argv [1], "--help")){
			LOG ("Usage: ./Bin/simulate <config file> (default: Assets/Config/AppConfig.xml)");
			exit (EXIT_SUCCESS);
		}
	}

	// get the input configuration file (default:Assets/Config/EnumTypes.xml)
	const char* input = nullptr;
	if (argc < 2){
		input = "Assets/Config/EnumTypes.xml";
		LOG ("No input file specified, default " << input << " being used");
	} else {
		input = argv [1];
	}

	// open input configuration file
	Sim::ConfigParser cp;
	if (!cp.Initialize (input, "EnumTypes")){
		LOG_ERROR ("Could not initialize parser for " << input << "...Aborting");
		exit (EXIT_FAILURE);
	}

	// get the location of output file
	XMLElement* element = cp.GetElement ("Output");
	if (element == nullptr){
		LOG_ERROR ("No output folder specified by " << input << "...Aborting");
		exit (EXIT_FAILURE);
	}
	const char* location = element->Attribute ("Location");
	if (location == nullptr){
		LOG_ERROR ("No Location specified in \'Ouput\' element in " << input << "...Aborting");
		exit (EXIT_FAILURE);
	}

	element = cp.GetElement ("EnumType");
	if (element == nullptr){
		LOG_ERROR ("No enum types are specified in " << input << "...Aborting");
		exit (EXIT_FAILURE);
	}

	// generate file-name with location
	string filename (location);
	if (filename [filename.length () - 1] != '/'){
		filename += "/";
	}
	filename += "Types.h";

	ofstream file (filename, ios::out | ios::trunc);
	if (!file.is_open ()){
		LOG_ERROR ("Could not open " << filename);
		exit (EXIT_FAILURE);
	}

	// generate comment header
	file << "/**" << endl;
	file << " * @file Types.h" << endl;
	file << " * @author Kishalay Kundu <kishalay.kundu@gmail.com>" << endl;
	file << " * @section LICENSE" << endl;
	file << " * See LICENSE.txt included in this package" << endl;
	file << " *" << endl;
	file << " * @section DESCRIPTION" << endl;
	file << " * Enum classes used by the Canvas simulate system. Types.h is" << endl;
	file << " * automatically generated by the generateEnums program based on" << endl;
	file << " * input in " << input << endl;
	file << " */" << endl << endl;

	file << "#pragma once" << endl << endl;
	file << "#include <iostream>" << endl;
	file << "#include <string>" << endl << endl;

	file << "using std::ostream;" << endl;
	file << "using std::string;" << endl << endl;

	file << "namespace Sim {" << endl << endl;

	// all customized enums written here
	while (element != nullptr){

		const char* name = element->Attribute ("Name");
		if (name == nullptr){
			LOG_WARNING ("No name specified for \'EnumType\' element in " << input <<
					". No enum class generated. Proceeding with next element.");
		}
		else {

			// ENUM CLASS DECLARATION
			file << "\t enum class " << name << " {" << endl;

			XMLElement* type = element->FirstChildElement ("Type");
			while (type != nullptr){
				file << "\t\t" << type->GetText () << "," << endl;
				type = type->NextSiblingElement ("Type");
			}
			// add the default type - Unknown
			file << "\t\tUnknown" << endl;

			file << "\t };" << endl << endl;

			// OVERLOADED PRINT FUNCTION
			file << "\t inline ostream& operator << (ostream& output, const " << name << "& id)" << endl;
			file << "\t {" << endl;
			file << "\t\t switch (id){" << endl;

			type = element->FirstChildElement ("Type");
			while (type != nullptr){
				file << "\t\t case " << name << "::" << type->GetText () <<": output << \"" << type->GetText () << "\"; break;" << endl;
				type = type->NextSiblingElement ("Type");
			}
			file <<"\t\t default: output << \"Unknown\"; break;" << endl;

			file << "\t\t }" << endl;
			file << "\t\t return output;" << endl;
			file << "\t }" << endl << endl;

			// STRING TO ENUM CONVERTER LAMBDA FUNCTION
			file << "\t auto " << name << "ByName = [=] (const char* chr)" << endl;
			file << "\t {" << endl;
			file << "\t\t string str (chr);" << endl;

			type = element->FirstChildElement ("Type");
			bool first = true;
			while (type != nullptr){
				if (first){
					file << "\t\t if (!str.compare (\"" << type->GetText () <<"\")){" << endl;
					file << "\t\t\t return " << name << "::" << type->GetText () << ";" << endl;
					file << "\t\t }" << endl;
					first = false;
				}
				else {
					file << "\t\t else if (!str.compare (\"" << type->GetText () <<"\")){" << endl;
					file << "\t\t\t return " << name << "::" << type->GetText () << ";" << endl;
					file << "\t\t }" << endl;
				}
				type = type->NextSiblingElement ("Type");
			}
			file << "\t\t return " << name << "::Unknown;" << endl;

			file << "\t };" << endl << endl;
		}

		element = element->NextSiblingElement ("EnumType");
	}

	file << "}" << endl;

	file.close ();

	exit (EXIT_SUCCESS);
}
